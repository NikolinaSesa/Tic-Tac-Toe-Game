'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addMiddleware = addMiddleware;

var _koaCompose = require('koa-compose');

var _koaCompose2 = _interopRequireDefault(_koaCompose);

var _graphql = require('graphql');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const wrapMiddleware = function wrapMiddleware(fn) {
  return function () {
    let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let next = arguments[1];

    const args = (context.args || []).concat(next);
    return fn.apply(this, args);
  };
};

const getType = function getType(type) {
  type = (0, _graphql.getNullableType)(type);
  if (type.ofType) {
    type = getType(type.ofType);
  }
  return type;
};

const pre = function pre(pre, fn) {
  pre = wrapMiddleware(pre);
  if (!fn.__chain) {
    fn = function (fn) {
      return (() => {
        var _ref = _asyncToGenerator(function* (_ref2) {
          let { args } = _ref2;

          return fn.apply(this, args);
        });

        return function (_x2) {
          return _ref.apply(this, arguments);
        };
      })();
    }(fn);
  }
  const chain = fn.__chain || [fn];
  const last = chain.pop();
  chain.push(pre);
  chain.push(last);
  const newFn = (0, _koaCompose2.default)(chain);
  const wrappedFn = (() => {
    var _ref3 = _asyncToGenerator(function* () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return newFn.call(this, { args });
    });

    return function wrappedFn() {
      return _ref3.apply(this, arguments);
    };
  })();
  wrappedFn.__chain = chain;
  return wrappedFn;
};

function addMiddleware(schema, path, fn) {
  if (!fn) {
    fn = path;
    path = null;
  }
  let parentType, parentField;
  if (path) {
    [parentType, parentField] = path.split('.');
  }
  const rootTypes = [schema.getQueryType(), schema.getMutationType(), schema.getSubscriptionType()].filter(x => !!x);
  let middlewaredTypes = {};
  rootTypes.forEach(type => {
    middlewaredTypes = addMiddlewareToType(type, fn, { parentType, parentField, middlewaredTypes });
  });
};

const addMiddlewareToType = function (type, fn, _ref4) {
  let {
    parentType,
    parentField,
    middlewaredTypes = {}
  } = _ref4;


  if (type && type.name && middlewaredTypes[type.name]) {
    // Stop going into recursion with adding middlewares
    // on recursive types
    return middlewaredTypes;
  } else {
    middlewaredTypes[type.name] = true;
  }

  const matchesParent = parentType ? parentType === type.name : true;
  const fields = type.getFields();
  Object.keys(fields).forEach(fieldName => {
    const matchesField = parentField ? parentField === fieldName : true;
    if (fields[fieldName].resolve && matchesField && matchesParent) {
      fields[fieldName].resolve = pre(fn, fields[fieldName].resolve);
    }
    const fieldType = getType(fields[fieldName].type);
    if (fieldType.getFields) {
      addMiddlewareToType(fieldType, fn, {
        parentType,
        parentField,
        middlewaredTypes
      });
    }
  });

  return middlewaredTypes;
};